var documenterSearchIndex = {"docs":
[{"location":"examples/phi_four_topologies/#ϕ4-Feynman-Diagram-Topologies","page":"Feynman diagrams","title":"ϕ^4 Feynman Diagram Topologies","text":"This example demonstrates how to compute the unique, connected Feynman diagram topologies for a scalar phi-four theory using the GraphCombinations.jl package.\n\nIn field theory one often want to compute the correlation function of some interaction lagrangian mathcalL_mathrmint. To do this one computes the average to k-th order in mathcalL_mathrmint: langle phi(1) barphi(2) mathcalL_mathrmint^k rangle_0, where the zero underscipt indicates that the correlator is dressed by the linear part of the system. barphi(2) indicates that a excitation in the field phi is created at position 2 and barphi(1) a excitation being destroyed at position 1. The internal interaction processes are determined by mathcalL_mathrmint.\n\nWick theorem allows us to represent in terms of the Feynman diagrams, by rewriting the average at k-th order in terms of two-point correlators. The Feynman diagrams are represented by a graph where the external legs correspond to the incoming and outgoing particle and the internal edges correspond to the interaction vertices.\n\nIn this example we will compute the topologies for the phi^4 theory, i.e., mathcalL_mathrmint = fraclambda4 barphi^2 phi^2. Hence, the graphs/diagram ar made of 2 vertices of degree 1 (external legs) and k vertices of degree 4 (interaction vertices).\n\nWe will compute al possible feynman diagram topologies for the first orders of the theory.\n\nusing GraphCombinations, GraphMakie, CairoMakie\nimport GraphMakie.NetworkLayout as NL\nimport GraphCombinations as GC\n\nfunction pltkwargs(g)\n    (;\n        layout=NL.Align(NL.Spring()),\n        curve_distance=GC.gen_distances(g),\n        curve_distance_usage=true,\n    )\nend","category":"section"},{"location":"examples/phi_four_topologies/#First-Order","page":"Feynman diagrams","title":"First Order","text":"As discussed above the diagrams to first order will have 2 external legs (degree 1) and 1 interaction vertex with degree 4.\n\nn1 = [2, 0, 0, 1]\ntopologies_order1 = allgraphs(n1)\n\nOnly one topology is possible for the first order.\n\ngraph, symmetry_factor = first(topologies_order1)\ng = build_graph(graph)\nf, ax, p = graphplot(g; pltkwargs(g)...)\nhidedecorations!(ax);\nhidespines!(ax);\nax.aspect = DataAspect();\nf","category":"section"},{"location":"examples/phi_four_topologies/#Second-Order","page":"Feynman diagrams","title":"Second Order","text":"In second order the graphs will have to 2 external legs (degree 1) and 2 interaction vertices of degree 4.\n\nn2 = [2, 0, 0, 2]\ntopologies_order2 = allgraphs(n2)\n\nHence, if we need to draw all diagrams to second order, we need to consider all three topologies.\n\nf = Figure(; size=(500, 500))\naxs = map(i -> Axis(f[i, 1]), 1:3)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order2[i]\n    g = build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf","category":"section"},{"location":"examples/phi_four_topologies/#Third-Order","page":"Feynman diagrams","title":"Third Order","text":"n3 = [2, 0, 0, 3]\ntopologies_order3 = allgraphs(n3)\n\nFor third order, we find 10 diagrams and that is why you will not easy find third order calculation in field theory :p .\n\nf = Figure(; size=(500, 500))\naxs_idx = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1)]\naxs = map(i -> Axis(f[i...]), axs_idx)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order3[i]\n    g = build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#GraphCombinations.jl","page":"Home","title":"GraphCombinations.jl","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet) (Image: DispatchDoctor)\n\nGraphCombinations.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.\n\nThe implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)\n\nThis package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. ","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"section"},{"location":"API/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"API/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"API/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"API/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"API/#GraphCombinations","page":"API","title":"GraphCombinations","text":"GraphCombinations.jl\n\n(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet) (Image: DispatchDoctor)\n\nGraphCombinations.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.\n\nThe implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)\n\nThis package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. \n\n\n\n\n\n","category":"module"},{"location":"API/#GraphCombinations.allgraphs","page":"API","title":"GraphCombinations.allgraphs","text":"allgraphs(\n    n::Vector{Int64};\n    connected\n) -> Vector{Tuple{Vector{Pair{Int64, Int64}}, Float64}}\n\n\nGenerates all unique topologies for a given vertex specification. It takes in a vector where n[k] is the number of vertices of degree k. By default, it generates connected graphs, unconnected can be computed by setting the keyword argument connected=false.\n\nReturns a Vector of Tuples (Vector{Edge}, S) with Edge a Tuple{Int64,Int64} representing an edge in the graph and S::Float64 the corresponding symmetry factor.\n\nExample\n\nFor input n = [2, 0, 0, 2] (2 vertices of degree 1, 2 vertex of degree 4):\n\njulia> using GraphCombinations\n\njulia> allgraphs([2, 0, 0, 2])\n3-element Vector{Tuple{Vector{Pair{Int64, Int64}}, Float64}}:\n ([1 => 3, 2 => 3, 3 => 4, 3 => 4, 4 => 4], 4.0)\n ([1 => 3, 2 => 4, 3 => 3, 3 => 4, 4 => 4], 4.0)\n ([1 => 3, 2 => 4, 3 => 4, 3 => 4, 3 => 4], 6.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.build_graph","page":"API","title":"GraphCombinations.build_graph","text":"build_graph(\n    graph_rep::Vector{Pair{Int64, Int64}},\n    num_vertices::Int64\n) -> GraphCombinations.MultigraphWrap{Int64}\n\n\nBuilds a MultigraphWrap from an edges list.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.combinatoric_factor","page":"API","title":"GraphCombinations.combinatoric_factor","text":"combinatoric_factor(n) -> Any\n\n\nComputes the combinatorial factor for graph symmetry calculations.\n\nThis function calculates the product of two factors:\n\nThe vertex permutation factor: number of ways to permute identical internal vertices\nThe edge endpoint permutation factor: number of ways to permute edge endpoints attached to vertices of the same degree\n\nThis factor is used in the calculation of symmetry factors for Feynman diagrams.\n\nParameters\n\nn: Vector where n[k] is the number of vertices with degree k\n\nReturns\n\nA floating point number representing the total combinatorial factor\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.total_degree","page":"API","title":"GraphCombinations.total_degree","text":"total_degree(n::Vector{Int64}) -> Int64\n\n\nCalculates the total degree of a graph topology represented by a vector of the degrees of vertices.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.canonical_form","page":"API","title":"GraphCombinations.canonical_form","text":"canonical_form(graph::GraphRep, internal_indices::UnitRange{Int})::GraphRep\n\nFinds the canonical representation of a graph under permutations of internal vertices. The canonical form is the lexicographically smallest graph representation achievable through permutation of internal_indices.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.MultigraphWrap","page":"API","title":"GraphCombinations.MultigraphWrap","text":"MultigraphWrap{T} <: AbstractGraph{T}\n\nA wrapper for Multigraph that implements the AbstractGraph interface from Graphs.jl.\n\nThis wrapper is necessary because GraphMakie.jl only supports the Graphs.jl interface, but not Multigraphs.jl directly. See the discussion at https://github.com/MakieOrg/GraphMakie.jl/issues/52 for more details.\n\nThe wrapper provides all necessary methods to make a Multigraph compatible with functions expecting an AbstractGraph from Graphs.jl, especially for visualization purposes with GraphMakie.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#GraphCombinations.corr","page":"API","title":"GraphCombinations.corr","text":"corr(points::Vector{Int})\n\nComputes all possible pairings (Wick contractions) of the given points. Points are represented by integers. The function returns a list of \"terms\", where each term is a list of Edge (Pair{Int, Int}) objects.\n\nEdges a => b always have a < b.\n\nExamples\n\njulia> import GraphCombinations as GC\n\njulia> GC.corr([1,2,3,4])\n3-element Vector{Vector{Pair{Int64, Int64}}}:\n [1 => 2, 3 => 4]\n [1 => 3, 2 => 4]\n [1 => 4, 2 => 3]\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.sort_graph_edges","page":"API","title":"GraphCombinations.sort_graph_edges","text":"sort_graph_edges(graph::GraphRep)::GraphRep\n\nSorts edges within a graph representation canonically. Ensures a < b in each a => b and then sorts the vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.create_points","page":"API","title":"GraphCombinations.create_points","text":"create_points(n::Vector{Int64}) -> Vector{Int64}\n\n\nConverts a vertex degree specification n to a flat array of vertex indices.\n\nFor a vector n where n[k] specifies the number of vertices with degree k, this function creates a vector where each vertex index appears a number of times equal to its degree. This representation is used for generating all possible pairings in the correlation function calculation.\n\nExample\n\nFor input n = [2, 1] (2 vertices of degree 1, 1 vertex of degree 2):\n\njulia> import GraphCombinations as GC\n\njulia> GC.create_points([2, 1])\n4-element Vector{Int64}:\n 1\n 2\n 3\n 3\n\n\n\n\n\n","category":"function"}]
}
