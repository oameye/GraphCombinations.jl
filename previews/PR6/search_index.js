var documenterSearchIndex = {"docs":
[{"location":"examples/phi_four_topologies/#ϕ4-Feynman-Diagram-Topologies","page":"Feynman diagrams","title":"ϕ^4 Feynman Diagram Topologies","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"This example demonstrates how to compute the unique, connected Feynman diagram topologies for a scalar phi-four theory using the GraphCombinatorics.jl package.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In field theory one often want to compute the correlation function of some interaction lagrangian mathcalL_mathrmint. To do this one computes the average to k-th order in mathcalL_mathrmint: langle phi(1) barphi(2) mathcalL_mathrmint^k rangle_0, where the zero underscipt indicates that the correlator is dressed by the linear part of the system. barphi(2) indicates that a excitation in the field phi is created at position 2 and barphi(1) a excitation being destroyed at position 1. The internal interaction processes are determined by mathcalL_mathrmint.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Wick theorem allows us to represent in terms of the Feynman diagrams, by rewriting the average at k-th order in terms of two-point correlators. The Feynman diagrams are represented by a graph where the external legs correspond to the incoming and outgoing particle and the internal edges correspond to the interaction vertices.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In this example we will compute the topologies for the phi^4 theory, i.e., mathcalL_mathrmint = fraclambda4 barphi^2 phi^2. Hence, the graphs/diagram ar made of 2 vertices of degree 1 (external legs) and k vertices of degree 4 (interaction vertices).","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"We will compute al possible feynman diagram topologies for the first orders of the theory.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"using GraphCombinatorics, GraphMakie, CairoMakie\nimport GraphMakie.NetworkLayout as NL\nimport GraphCombinatorics as GC\n\nfunction pltkwargs(g)\n    (;\n        layout=NL.Align(NL.Spring()),\n        curve_distance=GC.gen_distances(g),\n        curve_distance_usage=true,\n    )\nend","category":"page"},{"location":"examples/phi_four_topologies/#First-Order","page":"Feynman diagrams","title":"First Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"As discussed above the diagrams to first order will have 2 external legs (degree 1) and 1 interaction vertex with degree 4.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n1 = [2, 0, 0, 1]\ntopologies_order1 = allgraphs(n1)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Only one topology is possible for the first order.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"graph, symmetry_factor = first(topologies_order1)\ng = GC.build_graph(graph)\nf, ax, p = graphplot(g; pltkwargs(g)...)\nhidedecorations!(ax);\nhidespines!(ax);\nax.aspect = DataAspect();\nf","category":"page"},{"location":"examples/phi_four_topologies/#Second-Order","page":"Feynman diagrams","title":"Second Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In second order the graphs will have to 2 external legs (degree 1) and 2 interaction vertices of degree 4.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n2 = [2, 0, 0, 2]\ntopologies_order2 = allgraphs(n2)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Hence, if we need to draw all diagrams to second order, we need to consider all three topologies.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"f = Figure(; size=(500, 500))\naxs = map(i -> Axis(f[i, 1]), 1:3)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order2[i]\n    g = GC.build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf","category":"page"},{"location":"examples/phi_four_topologies/#Third-Order","page":"Feynman diagrams","title":"Third Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n3 = [2, 0, 0, 3]\ntopologies_order3 = allgraphs(n3)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"For third order, we find 10 diagrams and that is why you will not easy find third order calculation in field theory :p .","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"f = Figure(; size=(500, 500))\naxs_idx = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1)]\naxs = map(i -> Axis(f[i...]), axs_idx)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order3[i]\n    g = GC.build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GraphCombinatorics.jl","page":"Home","title":"GraphCombinatorics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphCombinatorics.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. ","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#GraphCombinatorics","page":"API","title":"GraphCombinatorics","text":"GraphCombinatorics.jl\n\n(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)\n\nGraphCombinatorics.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.\n\nThe implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)\n\nThis package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. \n\n\n\n\n\n","category":"module"},{"location":"API/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"API/#GraphCombinatorics.allgraphs","page":"API","title":"GraphCombinatorics.allgraphs","text":"allgraphs(\n    n::Vector{Int64}\n) -> Vector{Tuple{Vector{Pair{Int64, Int64}}, Float64}}\n\n\nGenerates all unique, connected topologies for a given vertex specification. It takes in a vector where n[k] is the number of vertices of degree k.\n\nReturns a Vector of Tuples (Vector{Edge}, S) with EdgeaTuple{Int64,Int64}representing an edge in the graph andS::Float64` the corresponding symmetry factor.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinatorics.build_graph","page":"API","title":"GraphCombinatorics.build_graph","text":"build_graph(\n    graph_rep::Vector{Pair{Int64, Int64}},\n    num_vertices::Int64\n) -> GraphCombinatorics.MultigraphWrap{Int64}\n\n\nBuilds a MultigraphWrap from an edges list.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinatorics.combinatoric_factor","page":"API","title":"GraphCombinatorics.combinatoric_factor","text":"combinatoric_factor(n) -> Any\n\n\nComputes the combinatorial factor for graph symmetry calculations.\n\nThis function calculates the product of two factors:\n\nThe vertex permutation factor: number of ways to permute identical internal vertices\nThe edge endpoint permutation factor: number of ways to permute edge endpoints attached to vertices of the same degree\n\nThis factor is used in the calculation of symmetry factors for Feynman diagrams.\n\nParameters\n\nn: Vector where n[k] is the number of vertices with degree k\n\nReturns\n\nA floating point number representing the total combinatorial factor\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinatorics.total_degree","page":"API","title":"GraphCombinatorics.total_degree","text":"total_degree(n::Vector{Int64}) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"API/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"API/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"API/#GraphCombinatorics.MultigraphWrap","page":"API","title":"GraphCombinatorics.MultigraphWrap","text":"MultigraphWrap{T} <: AbstractGraph{T}\n\nA wrapper for Multigraph that implements the AbstractGraph interface from Graphs.jl.\n\nThis wrapper is necessary because GraphMakie.jl only supports the Graphs.jl interface, but not Multigraphs.jl directly. See the discussion at https://github.com/MakieOrg/GraphMakie.jl/issues/52 for more details.\n\nThe wrapper provides all necessary methods to make a Multigraph compatible with functions expecting an AbstractGraph from Graphs.jl, especially for visualization purposes with GraphMakie.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"API/#GraphCombinatorics.corr","page":"API","title":"GraphCombinatorics.corr","text":"corr(points::Vector{Int})\n\nComputes all possible pairings (Wick contractions) of the given points. Points are represented by integers. The function returns a list of \"terms\", where each term is a list of Edge (Pair{Int, Int}) objects. Edges a => b always have a < b.\n\nExample: corr([1, 2, 3, 4]) might return [ [(1=>2), (3=>4)], [(1=>3), (2=>4)], [(1=>4), (2=>3)] ] (order may vary).\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinatorics.sort_graph_edges","page":"API","title":"GraphCombinatorics.sort_graph_edges","text":"sort_graph_edges(graph::GraphRep)::GraphRep\n\nSorts edges within a graph representation canonically. Ensures a < b in each a => b and then sorts the vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinatorics.canonical_form","page":"API","title":"GraphCombinatorics.canonical_form","text":"canonical_form(graph::GraphRep, internal_indices::UnitRange{Int})::GraphRep\n\nFinds the canonical representation of a graph under permutations of internal vertices. The canonical form is the lexicographically smallest graph representation achievable through permutation of internal_indices.\n\n\n\n\n\n","category":"function"}]
}
