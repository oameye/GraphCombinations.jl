var documenterSearchIndex = {"docs":
[{"location":"examples/phi_four_topologies/#ϕ4-Feynman-Diagram-Topologies","page":"Feynman diagrams","title":"ϕ^4 Feynman Diagram Topologies","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"This example demonstrates how to compute the unique, connected Feynman diagram topologies for a scalar phi-four theory using the GraphCombinations.jl package.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In field theory one often want to compute the correlation function of some interaction lagrangian mathcalL_mathrmint. To do this one computes the average to k-th order in mathcalL_mathrmint: langle phi(1) barphi(2) mathcalL_mathrmint^k rangle_0, where the zero underscipt indicates that the correlator is dressed by the linear part of the system. barphi(2) indicates that a excitation in the field phi is created at position 2 and barphi(1) a excitation being destroyed at position 1. The internal interaction processes are determined by mathcalL_mathrmint.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Wick theorem allows us to represent in terms of the Feynman diagrams, by rewriting the average at k-th order in terms of two-point correlators. The Feynman diagrams are represented by a graph where the external legs correspond to the incoming and outgoing particle and the internal edges correspond to the interaction vertices.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In this example we will compute the topologies for the phi^4 theory, i.e., mathcalL_mathrmint = fraclambda4 barphi^2 phi^2. Hence, the graphs/diagram ar made of 2 vertices of degree 1 (external legs) and k vertices of degree 4 (interaction vertices).","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"We will compute al possible feynman diagram topologies for the first orders of the theory.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"using GraphCombinations, GraphMakie, CairoMakie\nimport GraphMakie.NetworkLayout as NL\nimport GraphCombinations as GC\n\nfunction pltkwargs(g)\n    (;\n        layout=NL.Align(NL.Spring()),\n        curve_distance=GC.gen_distances(g),\n        curve_distance_usage=true,\n    )\nend","category":"page"},{"location":"examples/phi_four_topologies/#First-Order","page":"Feynman diagrams","title":"First Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"As discussed above the diagrams to first order will have 2 external legs (degree 1) and 1 interaction vertex with degree 4.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n1 = [2, 0, 0, 1]\ntopologies_order1 = allgraphs(n1)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Only one topology is possible for the first order.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"graph, symmetry_factor = first(topologies_order1)\ng = build_graph(graph)\nf, ax, p = graphplot(g; pltkwargs(g)...)\nhidedecorations!(ax);\nhidespines!(ax);\nax.aspect = DataAspect();\nf","category":"page"},{"location":"examples/phi_four_topologies/#Second-Order","page":"Feynman diagrams","title":"Second Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"In second order the graphs will have to 2 external legs (degree 1) and 2 interaction vertices of degree 4.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n2 = [2, 0, 0, 2]\ntopologies_order2 = allgraphs(n2)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"Hence, if we need to draw all diagrams to second order, we need to consider all three topologies.","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"f = Figure(; size=(500, 500))\naxs = map(i -> Axis(f[i, 1]), 1:3)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order2[i]\n    g = build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf","category":"page"},{"location":"examples/phi_four_topologies/#Third-Order","page":"Feynman diagrams","title":"Third Order","text":"","category":"section"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"n3 = [2, 0, 0, 3]\ntopologies_order3 = allgraphs(n3)","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"For third order, we find 10 diagrams and that is why you will not easy find third order calculation in field theory :p .","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"f = Figure(; size=(500, 500))\naxs_idx = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1)]\naxs = map(i -> Axis(f[i...]), axs_idx)\nfor (i, ax) in pairs(axs)\n    graph, symmetry_factor = topologies_order3[i]\n    g = build_graph(graph)\n    graphplot!(ax, g; pltkwargs(g)...)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    ax.aspect = DataAspect()\nend\nf","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"","category":"page"},{"location":"examples/phi_four_topologies/","page":"Feynman diagrams","title":"Feynman diagrams","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GraphCombinations.jl","page":"Home","title":"GraphCombinations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet) (Image: DispatchDoctor)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphCombinations.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. ","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#GraphCombinations","page":"API","title":"GraphCombinations","text":"GraphCombinations.jl\n\n(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet) (Image: DispatchDoctor)\n\nGraphCombinations.jl is a package for the generation of graphs for a given set of different vertices. Given a set of valent vertices (vertices of degree k), the package generates all possible graphs that can be constructed with these vertices.\n\nThe implementation is rather naive and I am sure it can be significiantly improved. Any contributions or suggestions are welcome :)\n\nThis package is heavily inspired by this StackExachange post by AccidentalFourierTransform. A mathematica notebook using his code can be found in the examples folder. \n\n\n\n\n\n","category":"module"},{"location":"API/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"API/#GraphCombinations.allgraphs","page":"API","title":"GraphCombinations.allgraphs","text":"allgraphs(\n    n::Vector{Int64};\n    connected\n) -> Vector{Tuple{Vector{Pair{Int64, Int64}}, Float64}}\n\n\nGenerates all unique topologies for a given vertex specification. It takes in a vector where n[k] is the number of vertices of degree k. By default, it generates connected graphs, unconnected can be computed by setting the keyword argument connected=false.\n\nReturns a Vector of Tuples (Vector{Edge}, S) with Edge a Tuple{Int64,Int64} representing an edge in the graph and S::Float64 the corresponding symmetry factor.\n\nExample\n\nFor input n = [2, 0, 0, 2] (2 vertices of degree 1, 2 vertex of degree 4):\n\njulia> using GraphCombinations\n\njulia> allgraphs([2, 0, 0, 2])\n3-element Vector{Tuple{Vector{Pair{Int64, Int64}}, Float64}}:\n ([1 => 3, 2 => 3, 3 => 4, 3 => 4, 4 => 4], 4.0)\n ([1 => 3, 2 => 4, 3 => 3, 3 => 4, 4 => 4], 4.0)\n ([1 => 3, 2 => 4, 3 => 4, 3 => 4, 3 => 4], 6.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.build_graph","page":"API","title":"GraphCombinations.build_graph","text":"build_graph(\n    graph_rep::Vector{Pair{Int64, Int64}},\n    num_vertices::Int64\n) -> GraphCombinations.MultigraphWrap{Int64}\n\n\nBuilds a MultigraphWrap from an edges list.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.combinatoric_factor","page":"API","title":"GraphCombinations.combinatoric_factor","text":"combinatoric_factor(n) -> Any\n\n\nComputes the combinatorial factor for graph symmetry calculations.\n\nThis function calculates the product of two factors:\n\nThe vertex permutation factor: number of ways to permute identical internal vertices\nThe edge endpoint permutation factor: number of ways to permute edge endpoints attached to vertices of the same degree\n\nThis factor is used in the calculation of symmetry factors for Feynman diagrams.\n\nParameters\n\nn: Vector where n[k] is the number of vertices with degree k\n\nReturns\n\nA floating point number representing the total combinatorial factor\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.total_degree","page":"API","title":"GraphCombinations.total_degree","text":"total_degree(n::Vector{Int64}) -> Int64\n\n\nCalculates the total degree of a graph topology represented by a vector of the degrees of vertices.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.canonical_form","page":"API","title":"GraphCombinations.canonical_form","text":"canonical_form(graph::GraphRep, internal_indices::UnitRange{Int})::GraphRep\n\nFinds the canonical representation of a graph under permutations of internal vertices. The canonical form is the lexicographically smallest graph representation achievable through permutation of internal_indices.\n\n\n\n\n\n","category":"function"},{"location":"API/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"API/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"API/#GraphCombinations.MultigraphWrap","page":"API","title":"GraphCombinations.MultigraphWrap","text":"MultigraphWrap{T} <: AbstractGraph{T}\n\nA wrapper for Multigraph that implements the AbstractGraph interface from Graphs.jl.\n\nThis wrapper is necessary because GraphMakie.jl only supports the Graphs.jl interface, but not Multigraphs.jl directly. See the discussion at https://github.com/MakieOrg/GraphMakie.jl/issues/52 for more details.\n\nThe wrapper provides all necessary methods to make a Multigraph compatible with functions expecting an AbstractGraph from Graphs.jl, especially for visualization purposes with GraphMakie.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"API/#GraphCombinations.corr","page":"API","title":"GraphCombinations.corr","text":"corr(points::Vector{Int})\n\nComputes all possible pairings (Wick contractions) of the given points. Points are represented by integers. The function returns a list of \"terms\", where each term is a list of Edge (Pair{Int, Int}) objects.\n\nEdges a => b always have a < b.\n\nExamples\n\njulia> import GraphCombinations as GC\n\njulia> GC.corr([1,2,3,4])\n3-element Vector{Vector{Pair{Int64, Int64}}}:\n [1 => 2, 3 => 4]\n [1 => 3, 2 => 4]\n [1 => 4, 2 => 3]\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.sort_graph_edges","page":"API","title":"GraphCombinations.sort_graph_edges","text":"sort_graph_edges(graph::GraphRep)::GraphRep\n\nSorts edges within a graph representation canonically. Ensures a < b in each a => b and then sorts the vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphCombinations.create_points","page":"API","title":"GraphCombinations.create_points","text":"create_points(n::Vector{Int64}) -> Vector{Int64}\n\n\nConverts a vertex degree specification n to a flat array of vertex indices.\n\nFor a vector n where n[k] specifies the number of vertices with degree k, this function creates a vector where each vertex index appears a number of times equal to its degree. This representation is used for generating all possible pairings in the correlation function calculation.\n\nExample\n\nFor input n = [2, 1] (2 vertices of degree 1, 1 vertex of degree 2):\n\njulia> import GraphCombinations as GC\n\njulia> GC.create_points([2, 1])\n4-element Vector{Int64}:\n 1\n 2\n 3\n 3\n\n\n\n\n\n","category":"function"}]
}
